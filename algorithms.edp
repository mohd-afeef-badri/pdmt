/*****************************************************************************

         This file is a part of PDMT (Parallel Dual Meshing Tool)

     -------------------------------------------------------------------

     Author(s): Mohd Afeef Badri
     Email    : mohd-afeef.badri@cea.com
     Date     : 14/01/2022
     Comment  : The program finds dual of a triangular mesh and then
                create a polyhedral mesh from the underlying Voronoi
                frame. The reason to use  PSD  for this meshing tool
                is the use of finite element framework for this tool

     -------------------------------------------------------------------

     PDMT a parallel  dual meshing tool uses   finite  element framework
     to convert a triangular / tetrahedral mesh into a  polyhedral  mesh.
     PDMT is distributed  in  the  hope that it  will be useful, HOWEVER
     WITHOUT ANY WARRANTY; or without  even  implied warranty of FITNESS
     FOR A PARTICULAR PURPOSE.

*******************************************************************************/


//-----------------------------------------
// Find Neighbours
//-----------------------------------------

macro identifyCellHeadAndNextVerticies()
  
  int[int] headv(Th.nv)  ,
           next(Th.nt*3) ;

  headv = -1;

  for(int k = 0; k < Th.nt; ++k){
    for(int i = 0; i < 3; ++i){
      int v = Th[k][i];        /* current vertex number */
      next[3*k+i] = headv[v];  /* next vertex           */
      headv[v]    = 3*k+i;     /* update head vertex    */
      cout << " k " << k << " i " << i << " Th["+k+"]["+i+"] " << Th[k][i] << " next["+int(3*k+i)+"] " << next[3*k+i] << " headv["+v+"] "<< headv[v] << endl; 
    }
  }
//



macro identifyBoundaryHeadAndNextVerticiesss()



  for(int k = 0; k < Th.nbe; ++k){
    for(int i = 0; i < 2; ++i){
      int v = Th.be(k)[i];        /* current vertex number */
      nextb[2*k+i] = headvb[v];  /* next vertex           */
      headvb[v]    = 2*k+i;     /* update head vertex    */
      cout << " k " << k << " i " << i << " Th["+k+"]["+i+"] " << Th.be(k)[i] << " next["+int(2*k+i)+"] " << nextb[2*k+i] << " headv["+v+"] "<< headvb[v] << endl; 
    }
  }
//




//-----------------------------------------
// Find border nodes using FEM variational formulation
//-----------------------------------------


macro identifyBorderAndNonBorderNodes()


  varf Gamma(u, v) = on(1,2,3,4, u = 1.0);

  real[int] onGamma(feSpcP1.ndof);
  onGamma = Gamma(0, feSpcP1, tgv = -1);

  int NodesInside = 0, NodesBorder = 0;

  for(int i = 0; i < feSpcP1.ndof; ++i){
    if(abs(onGamma[i]-1.0) < 0.1)
      NodesBorder++;
    else
      NodesInside++;
  }
//



macro calculateTotalLocalConnectivity()

  for(int v=0; v<Th.nv; ++v){
    if(abs(onGamma[v]-1.0) < 0.1){
      continue;
    }
    else{
      for(int p=headv[v]; p >=0; p=next[p]){
        nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
      }
    }
  }
//



macro initilizePolyMesh()

  int PolyNodesNumber =  Th.nt + Th.nbe + Th.nbe;
  real[int,int] PolyNodesVTK (PolyNodesNumber,2);

  int PolyCellNumber =  NodesInside + Th.nbe;
  int [int][int] PolyCellsVTK;
  PolyCellsVTK.resize(PolyCellNumber);

//

/*
  PolyNodesVTK(0:Th.nt,0) = ThP0x[];
  PolyNodesVTK(0:Th.nt,1) = ThP0y[];
 */ 
macro computePolyMesh(){

  real[int]  P0x(0), P0y(0), P0nI(0);
  int indexploy = 0;

  for(int v=0; v<Th.nv;++v){

    if(abs(onGamma[v]-1.0) < 0.1){
  
      P0x.resize(0); P0y.resize(0); P0nI.resize(0);  
      
      for(int p=headv[v]; p >=0; p=next[p]){
        cout << "not ok "<< p << "  " << p/2 <<endl;
      }
             cout << "\n\n " <<endl;
    }else{

      P0x.resize(0); P0y.resize(0); P0nI.resize(0);

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);

      for(int p=headv[v]; p >=0; p=next[p]){
       cout << "ok ok "<< p << "  " << p/3 <<endl;
        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = ThP0x[][k];
        P0y[P0y.n-1] = ThP0y[][k];
        P0nI[P0nI.n-1] = k;

      }
             cout << "\n\n " <<endl;
      pdmtConvexHull(P0x,P0y,P0nI);

      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk] = P0nI[kk];

      indexploy++;

    }
  }

}//
