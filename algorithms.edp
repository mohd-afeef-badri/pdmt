/*****************************************************************************

         This file is a part of PDMT (Parallel Dual Meshing Tool)

     -------------------------------------------------------------------

     Author(s): Mohd Afeef Badri
     Email    : mohd-afeef.badri@cea.com
     Date     : 14/01/2022
     Comment  : The program finds dual of a triangular mesh and then
                create a polyhedral mesh from the underlying Voronoi
                frame. The reason to use  PSD  for this meshing tool
                is the use of finite element framework for this tool

     -------------------------------------------------------------------

     PDMT a parallel  dual meshing tool uses   finite  element framework
     to convert a triangular / tetrahedral mesh into a  polyhedral  mesh.
     PDMT is distributed  in  the  hope that it  will be useful, HOWEVER
     WITHOUT ANY WARRANTY; or without  even  implied warranty of FITNESS
     FOR A PARTICULAR PURPOSE.

*******************************************************************************/


//-----------------------------------------
// Find Neighbours
//-----------------------------------------

macro identifyCellHeadAndNextVerticies()

  int[int] headv(Th.nv)  ,
           next(Th.nt*3) ;

  headv = -1;

  for(int k = 0; k < Th.nt; ++k){
    for(int i = 0; i < 3; ++i){
      int v = Th[k][i];        /* current vertex number */
      next[3*k+i] = headv[v];  /* next vertex           */
      headv[v]    = 3*k+i;     /* update head vertex    */
    }
  }
//


//-----------------------------------------
// Find border nodes using FEM variational formulation
//-----------------------------------------

macro identifyBorderAndNonBorderNodes()

  varf Gamma(u, v) = on(1,2,3,4, u = 1.0);

  real[int] onGamma(feSpcP1.ndof);
  onGamma = Gamma(0, feSpcP1, tgv = -1);

  int NodesInside = 0, NodesBorder = 0;

  for(int i = 0; i < feSpcP1.ndof; ++i){
    if(abs(onGamma[i]-1.0) < 0.1)
      NodesBorder++;
    else
      NodesInside++;
  }
//


macro calculateTotalLocalConnectivity()

  for(int v=0; v<Th.nv;++v){
    int localConnectivity = 0;
    if(abs(onGamma[v]-1.0) < 0.1){
      continue; /*cout << v << " Skip border node" << endl;*/
    }
    else{
      for(int p=headv[v]; p >=0; p=next[p]){
        int k = p/3, i = p%3;
        assert( Th[k][i]==v); /* check â€¦*/
        nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
      }
    }
  }
//



macro initilizePolyMesh()

  int PolyNodesNumber =  Th.nt;
  real[int,int] PolyNodesVTK (PolyNodesNumber,2);

  int PolyCellNumber =  NodesInside;
  int [int][int] PolyCellsVTK;
  PolyCellsVTK.resize(PolyCellNumber);

//


macro computePolyMesh(){

  PolyNodesVTK(:,0) = ThP0x[];
  PolyNodesVTK(:,1) = ThP0y[];


  real[int]  P0x(0), P0y(0), P0nI(0);
  int indexploy=0;

  for(int v=0; v<Th.nv;++v){

    int localConnectivity=0;

    if(abs(onGamma[v]-1.0) < 0.1)
      continue;  /*cout << v << " Skip border node" << endl;*/
    else{

      P0x.resize(0); P0y.resize(0); P0nI.resize(0);
      cout << v << " : ";

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);

      for(int p=headv[v]; p >=0; p=next[p]){

        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = ThP0x[][k];
        P0y[P0y.n-1] = ThP0y[][k];
        P0nI[P0nI.n-1] = k;

      }

      pdmtConvexHull(P0x,P0y,P0nI);

      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk]=P0nI[kk];

      indexploy++;

    }
  }

}//

