/*****************************************************************************

         This file is a part of PDMT (Parallel Dual Meshing Tool)

     -------------------------------------------------------------------

     Author(s): Mohd Afeef Badri
     Email    : mohd-afeef.badri@cea.com
     Date     : 14/01/2022
     Comment  : The program finds dual of a triangular mesh and then
                create a polyhedral mesh from the underlying Voronoi
                frame. The reason to use  PSD  for this meshing tool
                is the use of finite element framework for this tool

     -------------------------------------------------------------------

     PDMT a parallel  dual meshing tool uses   finite  element framework
     to convert a triangular / tetrahedral mesh into a  polyhedral  mesh.
     PDMT is distributed  in  the  hope that it  will be useful, HOWEVER
     WITHOUT ANY WARRANTY; or without  even  implied warranty of FITNESS
     FOR A PARTICULAR PURPOSE.

     -------------------------------------------------------------------

     USAGE:
     how to run

       PSD_Solve_Seq Main.edp --debug --mesh ./name/of/mesh/mesh.msh
       PSD_Solve_Seq Main.edp --mesh ./name/of/mesh/mesh.mesh

     command line parameters

       --debug    : to print some verbos info
       --mesh     : to provide external mesh (accepts .mesh and .msh)

*******************************************************************************/


load    "./cpp/pdmt";                    // Load pdmt library

include "getCommandLineInput.edp";       // Get commandline imput parameters
include "debug.edp";                     // Contains debug macros (verbos prints)
include "meshIO.edp";                    // mesh loading and saving
include "feSpacesAndVariables.edp";      // FEM spaces and variables
include "algorithms.edp";                // includes algorithms used


if (DEBUG){
  printProgramBegins;                 // prints only if --debug
  //mesh Th = loadTheMesh(ThName);

  mesh Th = loadTheMesh("square");
  
              
  saveInputMeshVtu;                   // saves  only if --debug
  printInputMeshStats;                // prints only if --debug

  buildFeSpacesAndVariables;

  printBarryCentersFromP0Space        // prints only if --debug
  
//  identifyBoundaryHeadAndNextVerticiesss;

  cout << " identifyBoundaryHeadAndNextVerticiesss identifyBoundaryHeadAndNextVerticiesss identifyBoundaryHeadAndNextVerticiesss " << endl; 

  int[int] isBorderNode(Th.nv); 
  isBorderNode = 0;
      
  int[int] headvb(Th.nv), nextb(Th.nbe*2);
  headvb = -1;
 
   for(int k = 0; k < Th.nbe; ++k){
    for(int i = 0; i < 2; ++i){
      int v = Th.be(k)[i];         /* current vertex number */
      nextb[2*k+i] = headvb[v];    /* next vertex           */
      headvb[v]    = 2*k+i;        /* update head vertex    */
      cout << " k " << k << " i " << i << " Th.be("+k+")["+i+"] " << Th.be(k)[i] << " next["+int(2*k+i)+"] " << nextb[2*k+i] << " headv["+v+"] "<< headvb[v] << endl; 
      isBorderNode[v] += 1; 
    }
  }
 
       cout << " DONE  " << endl; 
                
 // identifyCellHeadAndNextVerticies;

  int[int] headv(Th.nv), next(Th.nt*3) ;
  headv = -1;

  for(int k = 0; k < Th.nt; ++k){
    for(int i = 0; i < 3; ++i){
      int v = Th[k][i];        /* current vertex number */
      next[3*k+i] = headv[v];  /* next vertex           */
      headv[v]    = 3*k+i;     /* update head vertex    */
      cout << " k " << k << " i " << i << " Th["+k+"]["+i+"] " << Th[k][i] << " next["+int(3*k+i)+"] " << next[3*k+i] << " headv["+v+"] "<< headv[v] << endl; 
    }
  }
  

  printTriangleListForEachNode ;      // prints only if --debug

//  identifyBorderAndNonBorderNodes;

  int NodesInside = 0, NodesBorder = 0;

  for(int i = 0; i < Th.nv; ++i){
    if(isBorderNode[i])
      NodesBorder++;
    else
      NodesInside++;
  }
  
    
//  printNodeListBelonginToDomain;      // prints only if --debug


//  calculateTotalLocalConnectivity;


  printNumberOfAssociatedTria;        // prints only if --debug


  initilizePolyMesh;

  PolyNodesVTK(0:Th.nt,0) = ThP0x[];
  PolyNodesVTK(0:Th.nt,1) = ThP0y[];
  
  int polynodeindex = Th.nt;
  
   for(int v=0; v<Th.nv;++v){
     if(isBorderNode[v]){
        PolyNodesVTK(polynodeindex,0) = Th(v).x;
        PolyNodesVTK(polynodeindex,1) = Th(v).y;         
        polynodeindex++;
     }    
   }
 
   
   polynodeindex = Th.nt + Th.nbe;

   real[int] beElemenetNodeX(Th.nbe), beElemenetNodeY(Th.nbe);
   for(int v=0; v<Th.nbe;++v){
        beElemenetNodeX(v) = 0.5*(Th(Th.be(v)[0]).x + Th(Th.be(v)[1]).x);
        beElemenetNodeY(v) = 0.5*(Th(Th.be(v)[0]).y + Th(Th.be(v)[1]).y);
        
        PolyNodesVTK(polynodeindex,0) = beElemenetNodeX(v);
        PolyNodesVTK(polynodeindex,1) = beElemenetNodeY(v);
        polynodeindex++;
   }
       
  
//  computePolyMesh;

  real[int]  P0x(0), P0y(0), P0nI(0);
  int indexploy = 0;
  int indexnbe  = 0;

  for(int v=0; v<Th.nv;++v){

    if(isBorderNode[v]){
    
      P0x.resize(0); P0y.resize(0); P0nI.resize(0);


      for(int p=headv[v]; p >=0; p=next[p]){
        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1]   = ThP0x[][k];
        P0y[P0y.n-1]   = ThP0y[][k];
        P0nI[P0nI.n-1] = k; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
        cout << " headv --- "<< k << "  "; 
                
      }
        cout << "\n\n " <<endl;               
        
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1]   = Th(v).x;
        P0y[P0y.n-1]   = Th(v).y;
        P0nI[P0nI.n-1] = Th.nt + indexnbe; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
        indexnbe++;
        cout << " headless --- "<< Th.nt + indexnbe << "  "; 
        cout << "\n\n " <<endl;               
        
      for(int p=headvb[v]; p >=0; p=nextb[p]){
        int k = p/2;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = beElemenetNodeX(k);
        P0y[P0y.n-1] = beElemenetNodeY(k);
        P0nI[P0nI.n-1] = Th.nt + Th.nbe + k; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
         cout << " headvb --- "<< Th.nt + Th.nbe + k << "  ";       

      }
            
             cout << "\n\n " <<endl;
      pdmtConvexHull(P0x,P0y,P0nI);

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);
      
      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk] = P0nI[kk];


      for(int kk; kk < P0nI.n ; kk++)
        cout << "POLY vertex " << P0nI[kk] << "  ";
        
      cout << ""<< endl;

        
      indexploy++;
                   
    }else{

      P0x.resize(0); P0y.resize(0); P0nI.resize(0);



      for(int p=headv[v]; p >=0; p=next[p]){
       cout << "ok ok "<< p << "  " << p/3 <<endl;
        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = ThP0x[][k];
        P0y[P0y.n-1] = ThP0y[][k];
        P0nI[P0nI.n-1] = k;
        
        nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;

      }
             cout << "\n\n " <<endl;
      pdmtConvexHull(P0x,P0y,P0nI);

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);
      
      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk] = P0nI[kk];

      indexploy++;

    }
  }
  
  printPolyhedralMeshingStats;        // prints only if --debug
  savePolyMesh;
 
   for(int v=0; v<Th.nv;++v){
     cout << v << " : ";
     if(isBorderNode[v])
       for(int p=headvb[v], k; p >=0; p=nextb[p]){
          k=p/2;
          cout << k << " " ;
       }    
       cout << endl;
   }

       
  for(int k=0; k<Th.nbe;++k){
          cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label 
	       <<  " tria  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  endl;
  }     
  
 
}
else{
  mesh Th = loadTheMesh(ThName);
  buildFeSpacesAndVariables;
  identifyCellHeadAndNextVerticies;
  identifyBorderAndNonBorderNodes;
  calculateTotalLocalConnectivity;
  initilizePolyMesh;
  computePolyMesh;
  savePolyMesh;
}


    
