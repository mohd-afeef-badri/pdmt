/*****************************************************************************

         This file is a part of PDMT (Parallel Dual Meshing Tool)

     -------------------------------------------------------------------

     Author(s): Mohd Afeef Badri
     Email    : mohd-afeef.badri@cea.com
     Date     : 14/01/2022
     Comment  : The program finds dual of a triangular mesh and then
                create a polyhedral mesh from the underlying Voronoi
                frame. The reason to use  PSD  for this meshing tool
                is the use of finite element framework for this tool

     -------------------------------------------------------------------

     PDMT a parallel  dual meshing tool uses   finite  element framework
     to convert a triangular / tetrahedral mesh into a  polyhedral  mesh.
     PDMT is distributed  in  the  hope that it  will be useful, HOWEVER
     WITHOUT ANY WARRANTY; or without  even  implied warranty of FITNESS
     FOR A PARTICULAR PURPOSE.

     -------------------------------------------------------------------

     USAGE:
     how to run

       PSD_Solve_Seq Main.edp --debug --mesh ./name/of/mesh/mesh.msh
       PSD_Solve_Seq Main.edp --mesh ./name/of/mesh/mesh.mesh

     command line parameters

       --debug    : to print some verbos info
       --mesh     : to provide external mesh (accepts .mesh and .msh)

*******************************************************************************/


load    "./cpp/pdmt";                    // Load pdmt library

include "getCommandLineInput.edp";       // Get commandline imput parameters
include "debug.edp";                     // Contains debug macros (verbos prints)
include "meshIO.edp";                    // mesh loading and saving
include "feSpacesAndVariables.edp";      // FEM spaces and variables
include "algorithms.edp";                // includes algorithms used


if (DEBUG){
  printProgramBegins;                 // prints only if --debug

  mesh Th = loadTheMesh(ThName);
 // mesh Th = loadTheMesh("square");


  saveInputMeshVtu;                   // saves  only if --debug
  printInputMeshStats;                // prints only if --debug

  buildFeSpacesAndVariables;

  printBarryCentersFromP0Space        // prints only if --debug

//  identifyBoundaryHeadAndNextVerticiesss;

  cout << "------------------------- isBorderNode -------------------------" << endl;

  int[int] isBorderNode;
  PdmtMarkBorderNodes(Th,isBorderNode);

  cout << "------------------------- isBorderNode -------------------------" << endl;
  
  
  cout << "------------ identifyBoundaryHeadAndNextVerticiesss ------------" << endl;  
    
  int[int] headvb, nextb; 
  PdmtFillSearchTableEdges(Th,headvb,nextb);
  
  cout << "------------ identifyBoundaryHeadAndNextVerticiesss ------------" << endl;  
  
  

 // identifyCellHeadAndNextVerticies;

  int[int] headv, next ;   
  PdmtFillSearchTableTriangles(Th,headv,next);

  printTriangleListForEachNode ;      // prints only if --debug

//  identifyBorderAndNonBorderNodes;


  int NodesInside = 0, NodesBorder = 0;


  for(int i = 0; i < Th.nv; ++i){
    if(isBorderNode[i])
      NodesBorder++;
    else
      NodesInside++;
  }




//  printNodeListBelonginToDomain;      // prints only if --debug


//  calculateTotalLocalConnectivity;


  printNumberOfAssociatedTria;        // prints only if --debug


  initilizePolyMesh;

  PolyNodesVTK(0:Th.nt,0) = ThP0x[];
  PolyNodesVTK(0:Th.nt,1) = ThP0y[];

  int polynodeindex = Th.nt;

   for(int v=0; v<Th.nv;++v){
     if(isBorderNode[v]){
        PolyNodesVTK(polynodeindex,0) = Th(v).x;
        PolyNodesVTK(polynodeindex,1) = Th(v).y;
        polynodeindex++;
     }
   }


   polynodeindex = Th.nt + Th.nbe;

   real[int] beElemenetNodeX(Th.nbe), beElemenetNodeY(Th.nbe);
   for(int v=0; v<Th.nbe;++v){
        beElemenetNodeX(v) = 0.5*(Th(Th.be(v)[0]).x + Th(Th.be(v)[1]).x);
        beElemenetNodeY(v) = 0.5*(Th(Th.be(v)[0]).y + Th(Th.be(v)[1]).y);

        PolyNodesVTK(polynodeindex,0) = beElemenetNodeX(v);
        PolyNodesVTK(polynodeindex,1) = beElemenetNodeY(v);
        polynodeindex++;
   }


//  computePolyMesh;

  real[int]  P0x(0), P0y(0), P0nI(0);
  int indexploy = 0;
  int indexnbe  = 0;

  for(int v=0; v<Th.nv;++v){

    if(isBorderNode[v]){

      P0x.resize(0); P0y.resize(0); P0nI.resize(0);


      for(int p=headv[v]; p >=0; p=next[p]){
        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1]   = ThP0x[][k];
        P0y[P0y.n-1]   = ThP0y[][k];
        P0nI[P0nI.n-1] = k; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
        cout << " headv --- "<< k << "  ";

      }
        cout << "\n\n " <<endl;

        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1]   = Th(v).x;
        P0y[P0y.n-1]   = Th(v).y;
        P0nI[P0nI.n-1] = Th.nt + indexnbe; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
        indexnbe++;
        cout << " headless --- "<< Th.nt + indexnbe << "  ";
        cout << "\n\n " <<endl;

      for(int p=headvb[v]; p >=0; p=nextb[p]){
        int k = p/2;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = beElemenetNodeX(k);
        P0y[P0y.n-1] = beElemenetNodeY(k);
        P0nI[P0nI.n-1] = Th.nt + Th.nbe + k; nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;
         cout << " headvb --- "<< Th.nt + Th.nbe + k << "  ";

      }

             cout << "\n\n " <<endl;
      pdmtConvexHull(P0x,P0y,P0nI);

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);

      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk] = P0nI[kk];


      for(int kk; kk < P0nI.n ; kk++)
        cout << "POLY vertex " << P0nI[kk] << "  ";

      cout << ""<< endl;


      indexploy++;

    }else{

      P0x.resize(0); P0y.resize(0); P0nI.resize(0);



      for(int p=headv[v]; p >=0; p=next[p]){
       cout << "ok ok "<< p << "  " << p/3 <<endl;
        int k = p/3;
        P0x.resize(P0x.n+1);
        P0y.resize(P0y.n+1);
        P0nI.resize(P0nI.n+1);

        P0x[P0x.n-1] = ThP0x[][k];
        P0y[P0y.n-1] = ThP0y[][k];
        P0nI[P0nI.n-1] = k;

        nAssociateTriangles[][v] = nAssociateTriangles[][v] + 1;

      }
             cout << "\n\n " <<endl;
      pdmtConvexHull(P0x,P0y,P0nI);

      PolyCellsVTK[indexploy].resize(nAssociateTriangles[][v]);

      for(int kk; kk < P0nI.n ; kk++)
        PolyCellsVTK[indexploy][kk] = P0nI[kk];

      indexploy++;

    }
  }

  printPolyhedralMeshingStats;        // prints only if --debug
  savePolyMesh;

   for(int v=0; v<Th.nv;++v){
     cout << v << " : ";
     if(isBorderNode[v])
       for(int p=headvb[v], k; p >=0; p=nextb[p]){
          k=p/2;
          cout << k << " " ;
       }
       cout << endl;
   }


  for(int k=0; k<Th.nbe;++k){
          cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label
	       <<  " tria  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  endl;
  }

 cout << " NodesBorder " << NodesBorder << "  NodesInside " << NodesInside << endl;

  int[int] isBorderNodeE;
   


}
else{
  mesh Th = loadTheMesh(ThName);
  buildFeSpacesAndVariables;
  identifyCellHeadAndNextVerticies;
  identifyBorderAndNonBorderNodes;
  calculateTotalLocalConnectivity;
  initilizePolyMesh;
  computePolyMesh;
  savePolyMesh;
}



